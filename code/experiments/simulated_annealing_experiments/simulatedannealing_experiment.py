
from code.algorithms import random, simulatedannealing, housecounter
import matplotlib.pyplot as plt
import copy
import csv
from code.solutions import save_solution
from code.classes import model
from code.visualisatie import histogram, scatterplot
from code.experiments import random_experiment
from code.classes.model import Model
from code.classes.district import District


def simulated_an(number_of_switch: int, iterations: int, solution: Model, start_temp: int, raise_temp: int, iterations_without_change: int):
    """
    Run simulated annealing, given number of houses to switch, number of iterations,
    the start temperature, the raise temperature and the number of iterations,
    without any change in value, before raising the temperature.
    """
    sa = simulatedannealing.SimulatedAnnealing(solution, start_temp, raise_temp, iterations_without_change)
    print("Running the simulated annealing...")
    print(f"Costs before simulated annealing: {sa.model_temp.return_total_costs()}")
    sa.run(iterations, number_of_switch)

    lowest_costs = sa.best_model.return_total_costs()
    best_model = sa.best_model
    costs_flow = sa.values
    print(f"Costs after simulated annealing: {lowest_costs}")

    return best_model, lowest_costs, costs_flow


def house_counter_simulated_an(district: District, runs: int, number_of_switch: int, iterations: int, start_temp: int, raise_temp: int, iterations_without_change: int) -> None:
    """
    Run simulated annealing beginning with a valid solution generated by housecounter algorithm.
    """
    smallest_solution = model.Model(district)
    while smallest_solution.is_solution() is False:
        smallest_solution = model.Model(district)
        housecount = housecounter.Housecounter(smallest_solution)
        smallest_solution = housecount.run_housecounter()

    start_cost = 40000
    cost = []
    for i in range(runs):
        best_model, lowest_costs, costs = simulated_an(number_of_switch, iterations, smallest_solution, start_temp, raise_temp, iterations_without_change)
        if start_cost > best_model.return_total_costs():
            start_cost = best_model.return_total_costs()
            optimal_model = best_model
            costs_flow = costs
            cost.append(lowest_costs)
    # stands for Housecounter with Simulated Annealing
    letters = "HC_SA"

    saving_plots(district, runs, number_of_switch, iterations, costs_flow, cost, start_temp, raise_temp, optimal_model, letters)


def random_simulated_an(district: District, random_runs: int, runs: int, number_of_switch: int, iterations: int, start_temp: int, raise_temp: int, iterations_without_change: int) -> None:
    """
    Run simulated annealing beginning with a valid solution generated by random greedy algorithm.
    """
    start_cost = 40000
    cost = []
    for i in range(runs):
        random_solution, costs = random.run(random_runs, district)
        best_model, lowest_costs, costs = simulated_an(number_of_switch, iterations, random_solution, start_temp, raise_temp, iterations_without_change)
        if start_cost > best_model.return_total_costs():
            start_cost = best_model.return_total_costs()
            costs_flow = costs
            cost.append(lowest_costs)
            optimal_model = best_model
    # stands for Random Greedy with Simulated Annealing
    letters = "RG_SA"

    saving_plots(district, runs, number_of_switch, iterations, costs_flow, cost, start_temp, raise_temp, optimal_model, letters)


def saving_plots(district: District, runs: int, number_of_switch: int, iterations: int, costs_flow: list, total_costs_hist, start_temp: int, raise_temp: int, optimal_model: Model, start_model: Model) -> None:
    """
    Plots a grid of all connections of houses and batteries.
    A line graph of costs the and the iterations of 1 run.
    A histogram of the frequency and the scores of multiple runs.
    And a json file with all the connections.
    """
    # save scatterplot of best solution
    scatterplot.show_scatterplot(optimal_model, multiple_plots = False)
    plt.savefig(f"code/experiments/simulated_annealing_experiments/grid_district_{district.district}_iterations_{iterations}")
    plt.close()

    # save x, y plot showing convergence of algoritme of the best solution
    plt.plot(range(len(costs_flow)), costs_flow)
    plt.xlabel("Iterations")
    plt.ylabel("Total costs")
    plt.title(f"Best solution of simulated annealing in combination with {start_model}.")
    plt.savefig(f"code/experiments/simulated_annealing_experiments/{start_model}_runs_{runs}_starttemp_{start_temp}_raise_temp_{raise_temp}")
    plt.close()

    # save histogram of all outcomes after running simulated annealing  on start_model
    histogram.plotting_histogram(total_costs_hist, "Total costs", "Frequency", f"{start_model} ({iterations})")
    plt.savefig(f"code/experiments/simulated_annealing_experiments/histogram_{start_model}_district_{district.district}_starttemp_{start_temp}_raise_temp_{raise_temp}")
    plt.close()

    # save solution in json format
    save_solution.save(f"simulated_annealing_experiments/{start_model}_district_{district.district}_starttemp_{start_temp}_raise_temp_{raise_temp}.json", optimal_model)
